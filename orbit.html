<!DOCTYPE html>
<html>
<head>
    <title>Orbit</title>
    <meta charset="utf-8">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.169.0/examples/jsm/"
            }
        }
    </script>
  
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        class FixedSizeAxesHelper extends THREE.Object3D {
            constructor(viewportFraction, camera) {
                super();

                this.camera = camera;
                this.viewportFraction = clamp(viewportFraction, 0, 1);

                const axes = new THREE.AxesHelper(1);
                this.add(axes);
            }

            updateMatrixWorld(force) {
                super.updateMatrixWorld(force);

                const c = this.camera;

                if (c instanceof THREE.PerspectiveCamera) {
                    const dist = this.position.distanceTo(c.position);
                    const fov = c.fov * (Math.PI / 180); // in radians
                    const scale = dist / fov * this.viewportFraction;
                    this.scale.set(scale, scale, scale);
                } else if (c instanceof THREE.OrthographicCamera) {
                    const scale = (c.top-c.bottom) * this.viewportFraction;
                    this.scale.set(scale, scale, scale);
                }
            }
        }

        const timescale = 3600; // tick the simulation one hour every second
        const substeps = 1000;

        const G = 6.67430e-20;  // gravitational constant, in km
        const dmoon = 384400;  // distance from Earth to Moon in km
        const vmoon = 1.022;    // velocity of Moon in km/s
        const incmoon = 5.145 * (Math.PI / 180); // inclination of Moon's orbit in radians

        const earth = {
            mass: 5.972e24, // kg
            radius: 6371,   // km
            position: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            color: 0x2233ff,
        };

        const moon = {
            mass: 7.342e22, // kg
            radius: 1737,   // km
            position: new THREE.Vector3(dmoon * Math.cos(incmoon), dmoon * Math.sin(incmoon), 0),
            velocity: new THREE.Vector3(-vmoon * Math.sin(incmoon), vmoon * Math.cos(incmoon), 0),
            color: 0xcccccc,
        };

        const scene = new THREE.Scene();

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000000);
        const cameraDist = dmoon*2; // make earth and moon visible
        const cameraPos = new THREE.Vector3(0, 0, 1).normalize().multiplyScalar(cameraDist);
        camera.position.copy(cameraPos);
        camera.lookAt(0, 0, 0);
        camera.updateMatrixWorld();

        const control = new OrbitControls(camera, renderer.domElement);
        control.zoomSpeed = 2.0;
        control.panSpeed = 0.4;

        const axes = new FixedSizeAxesHelper(0.1, camera);
        scene.add(axes);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(ambientLight);

        function planetMesh(planet) {
            const geo = new THREE.SphereGeometry(planet.radius, 32, 32);
            const mat = new THREE.MeshPhongMaterial({color: planet.color});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(planet.position);
            return mesh;
        }

        const earthMesh = planetMesh(earth);
        const moonMesh = planetMesh(moon);

        scene.add(earthMesh);
        scene.add(moonMesh);

        const moonVelocityArrow = new THREE.ArrowHelper(
            moon.velocity.clone().normalize(),
            moon.position,
            100000,
            0xff0000,
        );
        scene.add(moonVelocityArrow);

        function handleResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', handleResize);

        function simulate(dt) {
            dt *= timescale;
            const dts = dt / substeps;

            for (let i = 0; i < substeps; i++) {
                const r = new THREE.Vector3().subVectors(moon.position, earth.position);
                const fmag = G * earth.mass * moon.mass / r.lengthSq();
                const f = r.clone().normalize().multiplyScalar(fmag);

                const ma = f.clone().divideScalar(moon.mass).negate();
                moon.velocity.add(ma.multiplyScalar(dts));
                moon.position.add(moon.velocity.clone().multiplyScalar(dts));

                const ea = f.clone().divideScalar(earth.mass);
                earth.velocity.add(ea.multiplyScalar(dts));
                earth.position.add(earth.velocity.clone().multiplyScalar(dts));
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            const dt = clock.getDelta();
            // don't simulate on the first frame, don't simulate if the browser throttled
            // requestAnimationFrame because we were in a background tab.
            if (0 < dt && dt < 0.1) {
                simulate(dt);
            }

            moonVelocityArrow.setDirection(moon.velocity.clone().normalize());
            moonVelocityArrow.position.copy(moon.position);

            earthMesh.position.copy(earth.position);
            moonMesh.position.copy(moon.position);
            renderer.render(scene, camera);
        }
        renderer.setAnimationLoop(animate);
    </script>
</body>
</html>
