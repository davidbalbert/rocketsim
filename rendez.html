<!DOCTYPE html>
<html>
<head>
    <title>Rendezvous</title>
    <meta charset="utf-8">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.169.0/examples/jsm/"
            }
        }
    </script>
  
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const G = 6.67430e-20;  // gravitational constant, in km

        const earth = {
            mass: 5.972e24, // kg
            radius: 6371,   // km
            position: new THREE.Vector3(0, 0, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            color: 0x2233ff,
        };

        const scene = new THREE.Scene();

        const renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000000);
        const cameraDist = earth.radius * 5;
        const cameraPos = new THREE.Vector3(1, 0.5, 1).normalize().multiplyScalar(cameraDist);
        camera.position.copy(cameraPos);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        const control = new OrbitControls(camera, renderer.domElement);
        control.zoomSpeed = 2.0;
        control.panSpeed = 0.4;

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        function latLonToVec(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const r = radius

            return new THREE.Vector3(
                -r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
        }

        function createEarth() {
            const geometry = new THREE.SphereGeometry(earth.radius, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x1a3f5c,  // Darker blue color
                transparent: true,
                opacity: 0.8,
                shininess: 10,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 3,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(earth.position);

            // https://github.com/nvkelso/natural-earth-vector/blob/master/geojson/ne_110m_coastline.geojson
            const loader = new THREE.FileLoader();
            loader.load('continents.geojson', (data) => {
                const geojson = JSON.parse(data);
                const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
                geojson.features.forEach((feature) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints(
                        feature.geometry.coordinates.map(coord =>
                            latLonToVec(coord[1], coord[0], earth.radius)
                        )
                    );
                    const line = new THREE.Line(geometry, material);
                    mesh.add(line);
                });
            });

            scene.add(mesh);
        }
        function createAxes() {
            const size = earth.radius * 3;
            const divisions = 10;

            const gridx = new THREE.GridHelper(size, divisions, 0xaaaaaaa, 0xaaaaaaa);
            gridx.rotation.z = Math.PI / 2;
            gridx.position.set(-size/2, 0, 0);
            scene.add(gridx);

            const gridy = new THREE.GridHelper(size, divisions, 0xaaaaaaa, 0xaaaaaaa);
            gridy.position.set(0, -size/2, 0);
            scene.add(gridy);

            const gridz = new THREE.GridHelper(size, divisions, 0xaaaaaaa, 0xaaaaaaa);
            gridz.rotation.x = Math.PI / 2;
            gridz.position.set(0, 0, -size / 2);
            scene.add(gridz);
        }

        createEarth();
        createAxes();

        function handleResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', handleResize);

        function simulate(dt) {
        }

        const clock = new THREE.Clock();
        function animate() {
            const dt = clock.getDelta();
            // don't simulate on the first frame, don't simulate if the browser throttled
            // requestAnimationFrame because we were in a background tab.
            if (0 < dt && dt < 0.1) {
                simulate(dt);
            }
            renderer.render(scene, camera);

        }
        renderer.setAnimationLoop(animate);
        handleResize();
    </script>
</body>
</html>
