<!DOCTYPE html>
<html>
<head>
    <title>Rendezvous</title>
    <meta charset="utf-8">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background-color: black;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Helvetica, Arial, sans-serif;
        }

        #clock {
            font-size: 16px;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #time-control {
            margin-top: 5px;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #time-control label {
            color: white;
            font-size: 14px;
            margin-bottom: 5px;
        }

        #time-scale {
            width: 200px;
        }

        #time-scale-value {
            color: white;
            font-size: 14px;
            margin-top: 5px;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@v0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.169.0/examples/jsm/"
            }
        }
    </script>
  
</head>
<body>
    <div id="controls">
        <div id="clock">00:00:00:00</div>
        <div id="time-control">
            <label for="time-scale">Speed</label>
            <input type="range" id="time-scale" min="0" max="4" step="0.1" value="0">
            <div id="time-scale-value">1x</div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const sin = Math.sin;
        const cos = Math.cos;
        const PI = Math.PI;

        function rad(degrees) {
            return degrees * Math.PI / 180;
        }

        let elapsedTime = 0;
        let timeScale = 1;

        const G = 6.67430e-20;  // gravitational constant, in km

        const earth = {
            mass: 5.972e24, // kg
            radius: 6371,   // km
            tilt: rad(23.44),
            position: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            rotation: 0,
            rotationalVelocity: 2*PI/86164.1, // rad/s. denominator is seconds in a sidereal day
            color: 0x2233ff,
        };

        // based on Gemini VI
        function makeSpacecraft() {
            const perigee = 161 + earth.radius;  // km
            const apogee = 259.4 + earth.radius; // km
            const inclination = rad(28.97);

            // vis-viva equation, solving for velocity at perigee
            const mu = G * earth.mass;
            const a = (perigee + apogee) / 2; // length of semi-major axis
            const r = perigee;
            const vmag = Math.sqrt(mu * (2/r - 1/a));
            
            return {
                mass: 3546, // kg
                position: new THREE.Vector3(perigee, 0, 0),
                velocity: new THREE.Vector3(0, vmag*cos(inclination), vmag*sin(inclination)),
                color: 0xffff00,
            }
        }
        const spacecraft = makeSpacecraft();


        const scene = new THREE.Scene();

        const renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000000);
        const cameraDist = earth.radius * 4;
        const cameraPos = new THREE.Vector3(0, 0, 1).normalize().multiplyScalar(cameraDist);
        camera.position.copy(cameraPos);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        const control = new OrbitControls(camera, renderer.domElement);
        control.zoomSpeed = 2.0;
        control.panSpeed = 0.4;

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(sin(rad(60)), 0, cos(rad(60)));
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        function latLonToVec(lat, lon, radius) {
            const phi = rad(90 - lat)
            const theta = rad(lon + 180)

            const r = radius

            return new THREE.Vector3(
                -r * sin(phi) * cos(theta),
                r * cos(phi),
                r * sin(phi) * sin(theta)
            );
        }

        function makeEarthMesh() {
            const geometry = new THREE.SphereGeometry(earth.radius, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x1a3f5c,  // Darker blue color
                transparent: true,
                opacity: 0.8,
                shininess: 10,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 3,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(earth.position);

            // axis of rotation
            const axisMaterial = new THREE.LineBasicMaterial({color: 0x555555});
            const axisGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, earth.radius*1.4, 0),
                new THREE.Vector3(0, -earth.radius*1.4, 0)
            ]);
            const axisLine = new THREE.Line(axisGeometry, axisMaterial);
            mesh.add(axisLine);

            // https://github.com/nvkelso/natural-earth-vector/blob/master/geojson/ne_110m_coastline.geojson
            const loader = new THREE.FileLoader();
            loader.load('continents.geojson', (data) => {
                const geojson = JSON.parse(data);
                const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
                geojson.features.forEach((feature) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints(
                        feature.geometry.coordinates.map(coord =>
                            latLonToVec(coord[1], coord[0], earth.radius)
                        )
                    );
                    const line = new THREE.Line(geometry, material);
                    mesh.add(line);
                });
            });

            const container = new THREE.Object3D();
            container.add(mesh);
            container.rotation.z = -earth.tilt;

            return [mesh, container];
        }
        const [earthMesh, earthContainer] = makeEarthMesh();
        scene.add(earthContainer);

        function makeSpacecraftMesh() {
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshBasicMaterial({color: spacecraft.color});
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(spacecraft.position);
            return mesh;
        }
        const spacecraftMesh = makeSpacecraftMesh();
        scene.add(spacecraftMesh);


        function handleResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', handleResize);

        const timeScaleSlider = document.getElementById('time-scale');
        const timeScaleValue = document.getElementById('time-scale-value');

        timeScaleSlider.addEventListener('input', function() {
            const value = parseFloat(this.value);
            timeScale = Math.pow(10, value);
            timeScaleValue.textContent = timeScale.toFixed(2) + 'x';
        });

        function updateClock(dt) {
            elapsedTime += dt;
            const days = Math.floor(elapsedTime / 86400);
            const hours = Math.floor((elapsedTime % 86400) / 3600);
            const minutes = Math.floor((elapsedTime % 3600) / 60);
            const seconds = Math.floor(elapsedTime % 60);
            const text = `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('clock').textContent = text;
        }

        function updateSpacecraftSize() {
            const d = camera.position.distanceTo(spacecraftMesh.position);
            const scale = d * 0.005;
            spacecraftMesh.scale.set(scale, scale, scale);
        }

        const steps = 1000;
        function simulate(dt) {
            earth.rotation += earth.rotationalVelocity * dt;

            const r = spacecraft.position.clone().sub(earth.position);
            const mu = G * earth.mass;
            const a = r.clone().normalize().multiplyScalar(-mu / r.lengthSq());

            const dts = dt / steps;
            const adts = a.clone().multiplyScalar(dts);

            for (let i = 0; i < steps; i++) {
                spacecraft.velocity.add(adts);
                spacecraft.position.add(spacecraft.velocity.clone().multiplyScalar(dts));
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            const dt = clock.getDelta();
            // don't simulate on the first frame, don't simulate if the browser throttled
            // requestAnimationFrame because we were in a background tab.
            if (0 < dt && dt < 0.1) {
                const scaled = dt * timeScale;
                updateClock(scaled);
                updateSpacecraftSize();
                simulate(scaled);
            }

            earthMesh.rotation.y = earth.rotation;
            spacecraftMesh.position.copy(spacecraft.position);

            renderer.render(scene, camera);

        }
        renderer.setAnimationLoop(animate);
        handleResize();
    </script>
</body>
</html>
